#!/usr/bin/python3

import mne, sys
import numpy as np
import matplotlib.pyplot as plt

from dataclasses import dataclass
from argparse import ArgumentParser
from mne.io import Raw, read_raw_edf
from mne.preprocessing import ICA
from typing import List, Optional, Union, Tuple


@dataclass
class Montage:
	system: str
	channels: list
	ref: str = None

Channel = Union[str, Tuple[str, str]]


REF_1020 = [
	
	# Monopolar channels
	 'Fp1', 'Fp2',   'F9',   'F7',   'F3',  'Fz',
	  'F4',  'F8',  'F10',  'FT9',  'FT7', 'FT8',
	'FT10',  'T9',   'T7',   'C3',   'Cz',  'C4',
	  'T8', 'T10',  'TP9',  'TP7',  'CPz', 'TP8',
	'TP10',  'P9',   'P7',   'P3',   'Pz',  'P4',
	  'P8', 'P10',  'PO7',  'PO8',   'O1',  'O2',
	  
	# Misc channels
	  'A1',  'A2', 'ECG1', 'ECG2', 'TRIG',
	
]

BANANA_1020 = [
	
	# Bipolar channels
	('Fp1', 'F7'), ('F7', 'T7'), ('T7', 'P7'), ('T7', 'O1'),
	('Fp2', 'F8'), ('F8', 'T8'), ('T8', 'P8'), ('P8', 'O2'),
	( 'Fz', 'Cz'), ('Cz', 'Pz'),
	('Fp1', 'F3'), ('F3', 'C3'), ('C3', 'P3'), ('P3', 'O1'),
	('Fp2', 'F4'), ('F4', 'C4'), ('C4', 'P4'), ('P4', 'O2'),
	
	# Misc channels
	'A1', 'A2', 'ECG1', 'ECG2', 'TRIG',

]

TRANSVERSE_1020 = [
	
	# Bipolar channels
	('F7', 'Fp1'), ('Fp1', 'Fp2'), ('Fp2', 'F8'),
	('F7',  'F3'), ( 'F3',  'Fz'), ( 'Fz', 'F4'), ('F4', 'F8'),
	('T3',  'C3'), ( 'C3',  'Cz'), ( 'Cz', 'C4'), ('C4', 'T4'),
	('T5',  'P3'), ( 'P3',  'Pz'), ( 'Pz', 'P4'), ('P4', 'T6'),
	('T5',  'O1'), ( 'O1',  'O2'), ( 'O2', 'T6'),
	
	# Misc channels
	'A1', 'A2', 'ECG1', 'ECG2', 'TRIG',

]

ICA_METHODS = [
	'fastica', 'infomax', 'picard',
]

MONTAGES = [
	('average_std1020', Montage(system='standard_1020', ref='average', channels=REF_1020)),
	('ref_std1020', Montage(system='standard_1020', ref=['A1', 'A2'], channels=REF_1020)),
	('banana_std1020', Montage(system='standard_1020', channels=BANANA_1020)),
	('transverse_std1020', Montage(system='standard_1020', channels=TRANSVERSE_1020)),
]


def make_argument_parser() -> ArgumentParser:
	parser = ArgumentParser(description='EEG signal data preprocessing tool')
	parser.add_argument('input', help='input EDF file to process')
	parser.add_argument('-q', '--quiet', action='store_true', help='do not show messages')
	parser.add_argument('-m', '--montage', choices=[name for name, _ in MONTAGES], default=MONTAGES[0][0], help='apply selected montage')
	parser.add_argument('-e', '--exclude', type=str, nargs='+', help='exclude selected channels')
	parser.add_argument('-c', '--channels', type=str, nargs='+', help='include selected channels')
	parser.add_argument('--ecg', type=str, nargs='+', help='mark channels as ECG channels')
	parser.add_argument('--eog', type=str, nargs='+', help='mark channels as EOG channels')
	parser.add_argument('--stim', type=str, nargs='+', help='mark channels as STIM channels')
	parser.add_argument('--bads', type=str, nargs='+', help='mark channels as bad channels')
	parser.add_argument('-fl', '--filter-low', type=float, default=1, help='low frequency signal limit in Hz')
	parser.add_argument('-fh', '--filter-high', type=float, default=70, help='high frequency signal limit in Hz')
	parser.add_argument('-fn', '--filter-notch', default='europe', help='notch frequency signal limit in Hz')
	parser.add_argument('-i', '--ica', action='store_true', help='perform ICA decomposition')
	pca_opts = parser.add_mutually_exclusive_group()
	pca_opts.add_argument('--pca-count', type=int, help='number of PCA components to keep')
	pca_opts.add_argument('--pca-variance', type=float, default=.95, help='keep as many PCA components as to explain given variance')
	parser.add_argument('--ica-seed', type=int, help='seed for deterministic ICA results')
	parser.add_argument('--ica-method', choices=ICA_METHODS, default=ICA_METHODS[0], help='ICA method to use')
	parser.add_argument('--ica-exclude', nargs='*', help='ICA components to exclude from result')
	parser.add_argument('--exclude-ecg', action='store_true', help='exclude ICA sources detected as ECG')
	parser.add_argument('--exclude-eog', action='store_true', help='exclude ICA sources detected as EOG')
	parser.add_argument('--show-components', action='store_true', help='show ICA sources')
	parser.add_argument('--show-sources', action='store_true', help='show ICA components')
	parser.add_argument('--show', action='store_true', help='show result EEG data')
	parser.add_argument('-o', '--output', help='save preprocessed EEG data to FIF file')
	return parser

def load_eeg_file(fname: str) -> Optional[Raw]:
	fname = fname.lower()
	if fname.endswith('.fif'):
		return Raw(fname, preload=True)
	if fname.endswith('.edf'):
		return load_edf_file(fname)
	return None

def load_edf_file(fname: str) -> Raw:
	raw = read_raw_edf(fname, stim_channel='TRIG', preload=True)
	raw.rename_channels({'FP1': 'Fp1', 'FP2': 'Fp2',
	                      'OD':  'A1',  'OI': 'A2'})
	return raw

def apply_signal_filters(raw: Raw, low_filter: float = 1, high_filter: float = 100, notch_filter: float =50) -> None:
	filtered = raw.filter(l_freq=low_filter, h_freq=high_filter, picks='data')
	if notch_filter is not None:
		filtered.notch_filter(notch_filter, picks='data')

def setup_montage_channels(raw: Raw, channels: List[Channel]) -> None:
	included = [ch for ch in channels if isinstance(ch, str)]
	ch_pairs = [ch for ch in channels if isinstance(ch, tuple)]
	if len(ch_pairs) > 0:
		anodes, cathodes = [a for a, _ in ch_pairs], [c for _, c in ch_pairs]
		mne.set_bipolar_reference(raw, anodes, cathodes, drop_refs=False, copy=False)
		included = [f'{a}-{c}' for a, c in zip(anodes, cathodes)] + included
	raw.pick_channels(included, ordered=True)

def get_ica_components(raw: Raw, method: str = 'fastica', pca_components: float = None, seed: float = None) -> ICA:
	ica = ICA(max_iter='auto', n_components=pca_components, random_state=seed)
	ica.fit(raw, picks='data')
	return ica

def parse_notch_filter_freqs(freq: Union[str, float]) -> Optional[float]:
	if freq == 'europe':
		freq = 50
	elif freq == 'usa':
		freq = 60
	
	if isinstance(freq, int):
		freq = np.arange(freq, freq * 5 + 1, freq)
		return freq
	
	return None


def main() -> None:
	parser = make_argument_parser()
	if len(sys.argv) == 1:
		parser.print_usage()
		sys.exit(-1)
	
	args = parser.parse_args()
	if args.quiet is True:
		mne.set_log_level('warning')
	
	raw = load_eeg_file(args.input)
	
	montage = dict(MONTAGES).get(args.montage)
	raw.set_montage(montage.system, on_missing='ignore')
	if montage.ref is not None:
		raw.set_eeg_reference(montage.ref)
	setup_montage_channels(raw, montage.channels)

	if args.channels is not None:
		raw.pick_channels(args.channels, ordered=True)
	if args.exclude is not None:
		raw.drop_channels(args.exclude)
	
	if args.ecg is None:
		raw.set_channel_types({ch: 'ecg' for ch in raw.ch_names
		                                 if ch.startswith('ECG')})
	else:
		raw.set_channel_types({ch: 'ecg' for ch in args.ecg})
	
	if args.eog is not None:
		raw.set_channel_types({ch: 'eog' for ch in args.eog})
	if args.stim is not None:
		raw.set_channel_types({ch: 'stim' for ch in args.stim})
	if args.bads is not None:
		raw.info['bads'].extend(args.bads)
	
	filtered = raw.copy()
	notch_freqs = parse_notch_filter_freqs(args.filter_notch)
	apply_signal_filters(filtered, low_filter=args.filter_low,
	                               high_filter=args.filter_high,
	                               notch_filter=notch_freqs)
	
	if args.ica is True:
		pca_components = args.pca_count or args.pca_variance
		ica = get_ica_components(filtered, method=args.ica_method,
		                         pca_components=pca_components,
		                         seed=args.ica_seed)
		
		if args.ica_exclude is not None:
			ica.exclude.extend(args.ica_exclude)
		if args.exclude_ecg is True:
			ecg_ids, _ = ica.find_bads_ecg(filtered)
			ica.exclude.extend(ecg_ids)
		if args.exclude_eog is True:
			eog_ids, _ = ica.find_bads_eog(filtered)
			ica.exclude.extend(eog_ids)
		
		if args.ica_exclude is None or args.show_components is True:
			ica.plot_sources(inst=filtered, block=False)
		if args.show_sources is True:
			ica.plot_components(inst=filtered)
		
		ica.apply(filtered)
		plt.show()
	
	if args.show:
		filtered.plot(block=True)
		plt.show()
	
	if args.output is not None:
		filtered.save(args.output, overwrite=True)


if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		print('Interrupted.', file=sys.stderr)
		sys.exit(-1)
