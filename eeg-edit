#!/usr/bin/python3

import mne, sys
import numpy as np
import matplotlib.pyplot as plt

from dataclasses import dataclass
from argparse import ArgumentParser
from mne.io import Raw, read_raw_edf
from mne.preprocessing import ICA
from typing import List, Optional, Union, Tuple


@dataclass
class Montage:
	system: str
	channels: list
	ref: str = None

Channel = Union[str, Tuple[str, str]]


REF_1020 = [
	
	# Monopolar channels
	 'Fp1', 'Fp2',   'F9',   'F7',  'F3',  'Fz',
	  'F4',  'F8',  'F10',  'FT9', 'FT7', 'FT8',
	'FT10',  'T9',   'T7',   'C3',  'Cz',  'C4',
	  'T8', 'T10',  'TP9',  'TP7', 'CPz', 'TP8',
	'TP10',  'P9',   'P7',   'P3',  'Pz',  'P4',
	  'P8', 'P10',  'PO7',  'PO8',  'O1',  'O2',
	  
	# Misc channels
	  'A1',  'A2', 'ECG1', 'ECG2',
	
]

BANANA_1020 = [
	
	# Bipolar channels
	('Fp1', 'F7'), ('F7', 'T7'), ('T7', 'P7'), ('T7', 'O1'),
	('Fp2', 'F8'), ('F8', 'T8'), ('T8', 'P8'), ('P8', 'O2'),
	( 'Fz', 'Cz'), ('Cz', 'Pz'),
	('Fp1', 'F3'), ('F3', 'C3'), ('C3', 'P3'), ('P3', 'O1'),
	('Fp2', 'F4'), ('F4', 'C4'), ('C4', 'P4'), ('P4', 'O2'),
	
	# Misc channels
	'A1', 'A2', 'ECG1', 'ECG2',

]

TRANSVERSE_1020 = [
	
	# Bipolar channels
	('F7', 'Fp1'), ('Fp1', 'Fp2'), ('Fp2', 'F8'),
	('F7',  'F3'), ( 'F3',  'Fz'), ( 'Fz', 'F4'), ('F4', 'F8'),
	('T3',  'C3'), ( 'C3',  'Cz'), ( 'Cz', 'C4'), ('C4', 'T4'),
	('T5',  'P3'), ( 'P3',  'Pz'), ( 'Pz', 'P4'), ('P4', 'T6'),
	('T5',  'O1'), ( 'O1',  'O2'), ( 'O2', 'T6'),
	
	# Misc channels
	'A1', 'A2', 'ECG1', 'ECG2',

]

ICA_METHODS = [
	'fastica', 'infomax', 'picard',
]

MONTAGES = [
	('ref_1020', Montage(system='standard_1020', ref=['A1', 'A2'], channels=REF_1020)),
	('average_1020', Montage(system='standard_1020', ref='average', channels=REF_1020)),
	('banana_1020', Montage(system='standard_1020', channels=BANANA_1020)),
	('transverse_1020', Montage(system='standard_1020', channels=TRANSVERSE_1020)),
]

def make_argument_parser() -> ArgumentParser:
	parser = ArgumentParser(description='EEG signal data preprocessing tool')
	parser.add_argument('input', help='input EDF file to process')
	parser.add_argument('-q', '--quiet', action='store_true', help='do not show messages')
	parser.add_argument('-m', '--montage', choices=[name for name, _ in MONTAGES], default=MONTAGES[0][0], help='apply selected montage')
	parser.add_argument('-c', '--channels', type=str, nargs='+', help='include selected channels')
	parser.add_argument('-e', '--exclude', type=str, nargs='+', help='exclude selected channels')
	parser.add_argument('--ecg', type=str, nargs='+', help='mark channels as ECG channels')
	parser.add_argument('--eog', type=str, nargs='+', help='mark channels as EOG channels')
	parser.add_argument('--stim', type=str, nargs='+', help='mark channels as STIM channels')
	parser.add_argument('--bads', type=str, nargs='+', help='mark channels as bad channels')
	parser.add_argument('-i', '--ica', action='store_true', help='perform ICA decomposition')
	parser.add_argument('-is', '--ica-seed', type=int, help='set seed for deterministic results')
	parser.add_argument('-im', '--ica-method', choices=ICA_METHODS, default=ICA_METHODS[0], help='ICA method to use')
	parser.add_argument('-ie', '--ica-exclude', nargs='*', help='ICA components to exclude from result')
	parser.add_argument('-fl', '--filter-low', type=float, default=1, help='low frequency signal limit in Hz')
	parser.add_argument('-fh', '--filter-high', type=float, default=70, help='high frequency signal limit in Hz')
	parser.add_argument('-fn', '--filter-notch', default='europe', help='notch frequency signal limit in Hz')
	parser.add_argument('--show-components', action='store_true', help='show ICA components')
	parser.add_argument('--show', action='store_true', help='show result EEG data')
	parser.add_argument('-o', '--output', help='save preprocessed EEG data to FIF file')
	return parser

def load_eeg_file(fname: str) -> Optional[Raw]:
	fname = fname.lower()
	if fname.endswith('.fif'):
		return Raw(fname, preload=True)
	if fname.endswith('.edf'):
		return load_edf_file(fname)
	return None

def load_edf_file(fname: str) -> Raw:
	raw = read_raw_edf(fname, preload=True)
	raw.rename_channels({'FP1': 'Fp1', 'FP2': 'Fp2',
	                      'OD':  'A1',  'OI': 'A2'})
	return raw

def apply_signal_filters(raw: Raw, low_filter=1, high_filter=100, notch_filter=None) -> None:
	filtered = raw.filter(l_freq=low_filter, h_freq=high_filter)
	if notch_filter is not None:
		filtered.notch_filter(notch_filter)

def setup_montage_channels(raw: Raw, channels: List[Channel]) -> None:
	included = []
	for ch in channels:
		if isinstance(ch, tuple):
			mne.set_bipolar_reference(raw, ch[0], ch[1], drop_refs=False, copy=False)
			included.append(f'{ch[0]}-{ch[1]}')
		else:
			included.append(ch)
	raw.pick_channels(included, ordered=True)

def get_ica_components(raw: Raw, method='fastica', seed=None) -> ICA:
	ica = ICA(max_iter='auto', random_state=seed)
	ica.fit(raw)
	return ica

def parse_notch_filter_freqs(freq: Union[str, int]) -> Optional[int]:
	if freq == 'europe':
		freq = 50
	elif freq == 'usa':
		freq = 60
	
	if type(freq) is int:
		freq = np.arange(freq, freq * 5 + 1, freq)
		return freq
	
	return None


def main() -> None:
	parser = make_argument_parser()
	if len(sys.argv) == 1:
		parser.print_usage()
		sys.exit(-1)
	
	args = parser.parse_args()
	if args.quiet is True:
		mne.set_log_level('warning')
	
	raw = load_eeg_file(args.input)
	
	montage = dict(MONTAGES).get(args.montage)
	raw.set_montage(montage.system, on_missing='ignore')
	if montage.ref is not None:
		raw.set_eeg_reference(montage.ref)
	setup_montage_channels(raw, montage.channels)

	if args.channels is not None:
		raw.pick_channels(args.channels, ordered=True)
	if args.exclude is not None:
		raw.drop_channels(args.exclude)
	
	if args.ecg is not None:
		raw.set_channel_types({ch: 'ecg' for ch in args.ecg})
	if args.eog is not None:
		raw.set_channel_types({ch: 'eog' for ch in args.eog})
	if args.stim is not None:
		raw.set_channel_types({ch: 'stim' for ch in args.stim})
	if args.bads is not None:
		raw.info['bads'].extend(args.bads)
	
	filtered = raw.copy()
	notch_freqs = parse_notch_filter_freqs(args.filter_notch)
	apply_signal_filters(filtered, low_filter=args.filter_low,
	                               high_filter=args.filter_high,
	                               notch_filter=notch_freqs)
	
	if args.ica is True:
		ica = get_ica_components(filtered, method=args.ica_method, seed=args.ica_seed)
		if args.ica_exclude is None:
			ica.plot_sources(inst=filtered, block=False)
		if args.show_components is True:
			ica.plot_components(inst=filtered)
		ica.apply(filtered, exclude=args.ica_exclude)
	
	if args.show:
		filtered.plot(block=True)
	
	if args.output is not None:
		filtered.save(args.output, overwrite=True)


if __name__ == '__main__':
	try:
		main()
	except KeyboardInterrupt:
		print('Interrupted.', file=sys.stderr)
		sys.exit(-1)
