#!/usr/bin/python3

import sys
from typing import *
from argparse import ArgumentParser

import mne
import numpy as np
import matplotlib.pyplot as plt
from mne.preprocessing import ICA
from mne.io import Raw, read_raw

ICA_METHODS = [
	'fastica', 'infomax', 'picard',
]

MONTAGES = {
	'standard_1020': [
		 'Fp1', 'Fp2',   'F9',   'F7',  'F3',  'Fz',
		  'F4',  'F8',  'F10',  'FT9', 'FT7', 'FT8',
		'FT10',  'T9',   'T7',   'C3',  'Cz',  'C4',
		  'T8', 'T10',  'TP9',  'TP7', 'CPz', 'TP8',
		'TP10',  'P9',   'P7',   'P3',  'Pz',  'P4',
		  'P8', 'P10',  'PO7',  'PO8',  'O1',  'O2',
		  'A1',  'A2', 'ECG1', 'ECG2',
	],
}

REF_METHODS = [
	'average', 'ears'
]

def make_argument_parser() -> ArgumentParser:
	MONTAGE_NAMES = [k for k in MONTAGES.keys()]
	parser = ArgumentParser(description='EEG signal data preprocessing tool')
	parser.add_argument('input', help='input EDF file to process')
	parser.add_argument('-q', '--quiet', action='store_true', help='do not show messages')
	parser.add_argument('-m', '--montage', choices=MONTAGE_NAMES, default=MONTAGE_NAMES[0], help='apply selected montage')
	parser.add_argument('-r', '--reference', nargs='+', default='average', help='reference channels to use'),
	parser.add_argument('-e', '--exclude', type=str, nargs='+', help='exclude selected channels')
	parser.add_argument('-c', '--channels', type=str, nargs='+', help='include selected channels')
	parser.add_argument('--ecg', type=str, nargs='+', help='mark channels as ECG channels')
	parser.add_argument('--eog', type=str, nargs='+', help='mark channels as EOG channels')
	parser.add_argument('--stim', type=str, nargs='+', help='mark channels as STIM channels')
	parser.add_argument('--bads', type=str, nargs='+', help='mark channels as bad channels')
	parser.add_argument('-fl', '--filter-low', type=float, default=.3, help='low frequency filter in Hz')
	parser.add_argument('-fh', '--filter-high', type=float, default=70, help='high frequency filter in Hz')
	parser.add_argument('-fn', '--filter-notch', default='europe', help='notch frequency filter in Hz')
	parser.add_argument('-i', '--ica', action='store_true', help='perform ICA decomposition')
	pca_opts = parser.add_mutually_exclusive_group()
	pca_opts.add_argument('--pca-count', type=int, help='number of PCA components to keep')
	pca_opts.add_argument('--pca-variance', type=float, help='keep as many PCA components as to explain given variance')
	parser.add_argument('--ica-seed', type=int, help='seed for deterministic ICA results')
	parser.add_argument('--ica-filter-low', type=float, default=1, help='low frequency filter before ICA analysis')
	parser.add_argument('--ica-method', choices=ICA_METHODS, default=ICA_METHODS[0], help='ICA method to use')
	parser.add_argument('--ica-exclude', nargs='*', help='ICA components to exclude from result')
	parser.add_argument('--exclude-ecg', action='store_true', help='exclude ICA sources detected as ECG')
	parser.add_argument('--exclude-eog', action='store_true', help='exclude ICA sources detected as EOG')
	parser.add_argument('--show-pca-variance', action='store_true', help='show cumulative PCA variance')
	parser.add_argument('--show-components', action='store_true', help='show ICA sources')
	parser.add_argument('--show-sources', action='store_true', help='show ICA components')
	parser.add_argument('--show', action='store_true', help='show result EEG data')
	parser.add_argument('-o', '--output', help='save preprocessed EEG data to FIF file')
	return parser

def load_file(fname: str) -> Optional[Raw]:
	raw = read_raw(fname, preload=True)
	if fname.endswith('.edf'):
		raw.rename_channels({'FP1': 'Fp1', 'FP2': 'Fp2',
		                      'OD':  'A1',  'OI':  'A2'})
	return raw

def apply_signal_filters(raw: Raw, low_filter: float = 1, high_filter: float = 100, notch_filter: float =50) -> None:
	filtered = raw.filter(l_freq=low_filter, h_freq=high_filter, picks='data')
	if notch_filter is not None:
		filtered.notch_filter(notch_filter, picks='data')

def perform_ica_analysis(raw: Raw, method: str = 'fastica', pca_components: float = None, seed: float = None) -> ICA:
	ica = ICA(max_iter='auto', n_components=pca_components, random_state=seed)
	return ica.fit(raw)

def parse_notch_filter_freqs(freq: Union[str, float]) -> Optional[float]:
	if freq == 'europe':
		freq = 50
	elif freq == 'usa':
		freq = 60
	
	if isinstance(freq, int):
		freq = np.arange(freq, freq * 5 + 1, freq)
		return freq
	
	return None

def is_ica_analysis_required(args: Mapping[str, any]) -> bool:
	return args.ica         or \
	       args.ica_exclude or \
	       args.exclude_ecg or \
	       args.exclude_eog

def main() -> Optional[int]:
	parser = make_argument_parser()
	if len(sys.argv) == 1:
		parser.print_usage()
		return -1
	
	args = parser.parse_args()
	if args.quiet:
		mne.set_log_level('warning')
	
	raw = load_file(args.input)
	channels = MONTAGES.get(args.montage)
	raw.pick_channels(channels, ordered=True)
	
	if args.ecg is None:
		raw.set_channel_types({ch: 'ecg' for ch in raw.ch_names
		                                 if ch.startswith('ECG')})
	else:
		raw.set_channel_types({ch: 'ecg' for ch in args.ecg})
	
	if args.eog is not None:
		raw.set_channel_types({ch: 'eog' for ch in args.eog})
	if args.stim is not None:
		raw.set_channel_types({ch: 'stim' for ch in args.stim})
	if args.bads is not None:
		raw.info['bads'].extend(args.bads)
	
	if args.channels:
		raw.pick(args.channels)
	if args.exclude:
		raw.drop_channels(args.exclude)
	
	raw.set_eeg_reference(args.reference)
	raw.set_montage(args.montage, on_missing='warn')
	
	notch_freqs = parse_notch_filter_freqs(args.filter_notch)
	apply_signal_filters(raw, low_filter=args.filter_low,
	                          high_filter=args.filter_high,
	                          notch_filter=notch_freqs)
	
	if is_ica_analysis_required(args):
		filtered = raw.copy().pick('data')
		filtered.filter(args.ica_filter_low, None)
		pca_components = args.pca_count or args.pca_variance
		ica = perform_ica_analysis(filtered, method=args.ica_method,
		                           pca_components=pca_components,
		                           seed=args.ica_seed)

		if args.show_pca_variance:
			pca_total_variance = sum(ica.pca_explained_variance_)
			x = np.arange(1, len(ica.pca_explained_variance_) + 1)
			y = np.cumsum(ica.pca_explained_variance_) / pca_total_variance
			plt.xlabel('number of components')
			plt.ylabel('cumulative explained variance')
			plt.plot(x, y)
			plt.show()
		
		if args.ica_exclude:
			ica.exclude.extend(args.ica_exclude)
		if args.exclude_ecg:
			ecg_ids, _ = ica.find_bads_ecg(raw)
			ica.exclude.extend(ecg_ids)
		if args.exclude_eog:
			eog_ids, _ = ica.find_bads_eog(raw)
			ica.exclude.extend(eog_ids)
		
		if args.show_sources:
			ica.plot_components(inst=filtered, show=False)
			plt.show(block=False)
		
		if args.ica or args.show_components:
			ica.plot_sources(inst=filtered, block=True)
		
		ica.apply(raw, n_pca_components=pca_components)
	
	if args.show:
		raw.plot(block=True)
	
	if args.output:
		raw.save(args.output, overwrite=True)


if __name__ == '__main__':
	try:
		ret = main()
		sys.exit(ret)
	
	except KeyboardInterrupt:
		print('Interrupted.', file=sys.stderr)
		sys.exit(-1)
	
	except Exception as e:
		print(f'Error: {e}.', file=sys.stderr)
		sys.exit(-1)
